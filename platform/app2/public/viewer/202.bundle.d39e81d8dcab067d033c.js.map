{"version":3,"file":"202.bundle.d39e81d8dcab067d033c.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/toArray.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/codeMeaningEquals.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/node_modules/tslib/tslib.es6.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/MeasurementReport.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Bidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Angle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CobbAngle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/isValidCornerstoneTrackingIdentifier.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CircleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/EllipticalROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RectangleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/PlanarFreehandROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateToolState.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/index.ts","webpack:///../../../node_modules/base64-js/index.js","webpack:///../../../node_modules/buffer/index.js","webpack:///../../../node_modules/ieee754/index.js","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js"],"sourcesContent":["const toArray = x => (Array.isArray(x) ? x : [x]);\n\nexport { toArray };\n","/**\n * Returns a function that checks if a given content item's ConceptNameCodeSequence.CodeMeaning\n * matches the provided codeMeaningName.\n * @param codeMeaningName - The CodeMeaning to match against.\n * @returns A function that takes a content item and returns a boolean indicating whether the\n * content item's CodeMeaning matches the provided codeMeaningName.\n */\nconst codeMeaningEquals = (codeMeaningName: string) => {\n    return (contentItem: any) => {\n        return (\n            contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName\n        );\n    };\n};\n\nexport { codeMeaningEquals };\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport { toArray, codeMeaningEquals } from \"../helpers\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass\n) {\n    const args = toolClass.getTID300RepresentationArguments(tool);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    static getSetupMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const defaultState = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            complete: true,\n            finding: findingGroup\n                ? addAccessors(findingGroup.ConceptCodeSequence)\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => {\n                return addAccessors(fsg.ConceptCodeSequence);\n            })\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n        const findingSite =\n            defaultState.findingSites && defaultState.findingSites[0];\n        if (findingSite) {\n            defaultState.location =\n                (findingSite[0] && findingSite[0].CodeMeaning) ||\n                findingSite.CodeMeaning;\n        }\n        return {\n            defaultState,\n            findingGroup,\n            findingSiteGroups,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(toolState, metadataProvider, options) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n        let allMeasurementGroups = [];\n        const firstImageId = Object.keys(toolState)[0];\n        if (!firstImageId) {\n            throw new Error(\"No measurements provided.\");\n        }\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n         */\n        const generalSeriesModule = metadataProvider.get(\n            \"generalSeriesModule\",\n            firstImageId\n        );\n\n        //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n        // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n        // which means that if the toolState is for multiple series, the report will have the incorrect\n        // SeriesInstanceUIDs\n        const { studyInstanceUID, seriesInstanceUID } = generalSeriesModule;\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n                ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n            };\n\n            if (\n                Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const derivationSourceDataset = {\n            StudyInstanceUID: studyInstanceUID,\n            SeriesInstanceUID: seriesInstanceUID\n            //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n            //SOPClassUID: sopClassUID,\n        };\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        derivationSourceDataset._meta = _meta;\n        derivationSourceDataset._vrMap = _vrMap;\n\n        const report = new StructuredReport([derivationSourceDataset]);\n\n        const contentItem = MeasurementReport.contentItem(\n            derivationSourceDataset\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     * @param {object} dataset dataset\n     * @param {object} hooks\n     * @param {function} hooks.getToolClass Function to map dataset to a tool class\n     * @returns\n     */\n    static generateToolState(dataset, hooks = {}) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            const measurementGroupContentSequence = toArray(\n                measurementGroup.ContentSequence\n            );\n\n            const TrackingIdentifierGroup =\n                measurementGroupContentSequence.find(\n                    contentItem =>\n                        contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                        TRACKING_IDENTIFIER\n                );\n\n            const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n\n            const toolClass = hooks.getToolClass\n                ? hooks.getToolClass(\n                      measurementGroup,\n                      dataset,\n                      registeredToolClasses\n                  )\n                : registeredToolClasses.find(tc =>\n                      tc.isValidCornerstoneTrackingIdentifier(\n                          TrackingIdentifierValue\n                      )\n                  );\n\n            if (toolClass) {\n                const measurement =\n                    toolClass.getMeasurementData(measurementGroup);\n\n                console.log(`=== ${toolClass.toolType} ===`);\n                console.log(measurement);\n\n                measurementData[toolClass.toolType].push(measurement);\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n","export default \"cornerstoneTools@^4.0.0\";\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            length: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Length.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const distance = tool.length;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass FreehandRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: FreehandRoi.toolType,\n            handles: {\n                points: [],\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const { GraphicData } = SCOORDGroup;\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            state.handles.points.push({\n                x: GraphicData[i],\n                y: GraphicData[i + 1]\n            });\n        }\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites, cachedStats = {} } = tool;\n        const { points } = handles;\n        const { area = 0, perimeter = 0 } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:FreehandRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === FreehandRoi.toolType;\n};\n\nMeasurementReport.registerTool(FreehandRoi);\n\nexport default FreehandRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\n\nclass Bidirectional {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const findingGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING\n        );\n\n        const findingSiteGroups = toArray(ContentSequence).filter(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE\n        );\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const { ReferencedSOPSequence } = longAxisSCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        // Long axis\n\n        const longestDiameter = String(\n            longAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const shortestDiameter = String(\n            shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const bottomRight = {\n            x: Math.max(\n                longAxisSCOORDGroup.GraphicData[0],\n                longAxisSCOORDGroup.GraphicData[2],\n                shortAxisSCOORDGroup.GraphicData[0],\n                shortAxisSCOORDGroup.GraphicData[2]\n            ),\n            y: Math.max(\n                longAxisSCOORDGroup.GraphicData[1],\n                longAxisSCOORDGroup.GraphicData[3],\n                shortAxisSCOORDGroup.GraphicData[1],\n                shortAxisSCOORDGroup.GraphicData[3]\n            )\n        };\n\n        const state = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            toolType: Bidirectional.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: longAxisSCOORDGroup.GraphicData[0],\n                    y: longAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 0\n                },\n                end: {\n                    x: longAxisSCOORDGroup.GraphicData[2],\n                    y: longAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 1\n                },\n                perpendicularStart: {\n                    x: shortAxisSCOORDGroup.GraphicData[0],\n                    y: shortAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 2\n                },\n                perpendicularEnd: {\n                    x: shortAxisSCOORDGroup.GraphicData[2],\n                    y: shortAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 3\n                },\n                textBox: {\n                    highlight: false,\n                    hasMoved: true,\n                    active: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true,\n                    x: bottomRight.x + 10,\n                    y: bottomRight.y + 10\n                }\n            },\n            invalidated: false,\n            isCreating: false,\n            longestDiameter,\n            shortestDiameter,\n            toolName: \"Bidirectional\",\n            visible: true,\n            finding: findingGroup\n                ? findingGroup.ConceptCodeSequence\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { start, end, perpendicularStart, perpendicularEnd } =\n            tool.handles;\n        const { shortestDiameter, longestDiameter, finding, findingSites } =\n            tool;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:Bidirectional\";\n\n        return {\n            longAxis: {\n                point1: start,\n                point2: end\n            },\n            shortAxis: {\n                point1: perpendicularStart,\n                point2: perpendicularEnd\n            },\n            longAxisLength: longestDiameter,\n            shortAxisLength: shortestDiameter,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === BIDIRECTIONAL;\n};\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalRoi\";\n\nclass EllipticalRoi {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const majorAxis = [\n            { x: GraphicData[0], y: GraphicData[1] },\n            { x: GraphicData[2], y: GraphicData[3] }\n        ];\n        const minorAxis = [\n            { x: GraphicData[4], y: GraphicData[5] },\n            { x: GraphicData[6], y: GraphicData[7] }\n        ];\n\n        // Calculate two opposite corners of box defined by two axes.\n\n        const minorAxisLength = Math.sqrt(\n            Math.pow(minorAxis[0].x - minorAxis[1].x, 2) +\n                Math.pow(minorAxis[0].y - minorAxis[1].y, 2)\n        );\n\n        const minorAxisDirection = {\n            x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n            y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n        };\n\n        const halfMinorAxisLength = minorAxisLength / 2;\n\n        // First end point of major axis + half minor axis vector\n        const corner1 = {\n            x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n        };\n\n        // Second end point of major axis - half of minor axis vector\n        const corner2 = {\n            x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n        };\n        const state = {\n            ...defaultState,\n            toolType: EllipticalRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            handles: {\n                end: {\n                    x: corner1.x,\n                    y: corner1.y,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    x: corner2.x,\n                    y: corner2.y,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start, end } = handles;\n        const { area } = cachedStats;\n\n        const halfXLength = Math.abs(start.x - end.x) / 2;\n        const halfYLength = Math.abs(start.y - end.y) / 2;\n\n        const points = [];\n\n        const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };\n\n        if (halfXLength > halfYLength) {\n            // X-axis major\n            // Major axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n            // Minor axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n        } else {\n            // Y-axis major\n            // Major axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n            // Minor axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n        }\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ELLIPTICALROI;\n};\n\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport default EllipticalRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleRoi\";\n\nclass CircleRoi {\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const center = { x: GraphicData[0], y: GraphicData[1] };\n        const end = { x: GraphicData[2], y: GraphicData[3] };\n\n        const state = {\n            ...defaultState,\n            toolType: CircleRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup\n                    ? NUMGroup.MeasuredValueSequence.NumericValue\n                    : 0,\n                // Dummy values to be updated by cornerstone\n                radius: 0,\n                perimeter: 0\n            },\n            handles: {\n                end: {\n                    ...end,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    ...center,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start: center, end } = handles;\n        const { area, radius } = cachedStats;\n\n        const perimeter = 2 * Math.PI * radius;\n        const points = [];\n\n        points.push(center);\n        points.push(end);\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === CIRCLEROI;\n};\n\nMeasurementReport.registerTool(CircleRoi);\n\nexport default CircleRoi;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\nclass ArrowAnnotate {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, findingGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const state = {\n            ...defaultState,\n            toolType: ArrowAnnotate.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: GraphicData[0],\n                    y: GraphicData[1],\n                    highlight: true,\n                    active: false\n                },\n                // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n                // use the actual endpoint.\n                end: {\n                    x:\n                        GraphicData.length == 4\n                            ? GraphicData[2]\n                            : GraphicData[0] + 20,\n                    y:\n                        GraphicData.length == 4\n                            ? GraphicData[3]\n                            : GraphicData[1] + 20,\n                    highlight: true,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            text,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const points = [tool.handles.start, tool.handles.end];\n\n        let { finding, findingSites } = tool;\n\n        const TID300RepresentationArguments = {\n            points,\n            trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: CORNERSTONEFREETEXT,\n                CodingSchemeDesignator: \"CST4\",\n                CodeMeaning: tool.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst COBB_ANGLE = \"CobbAngle\";\n\nclass CobbAngle {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: CobbAngle.toolType,\n            handles: {\n                start: {},\n                end: {},\n                start2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                end2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y,\n            state.handles.start2.x,\n            state.handles.start2.y,\n            state.handles.end2.x,\n            state.handles.end2.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const point3 = handles.start2;\n        const point4 = handles.end2;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === COBB_ANGLE;\n};\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Angle: TID300Angle } = utilities.TID300;\n\nconst ANGLE = \"Angle\";\n\nclass Angle {\n    /**\n     * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n     */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Angle.toolType,\n            handles: {\n                start: {},\n                middle: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.middle;\n        const point3 = handles.middle;\n        const point4 = handles.end;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ANGLE;\n};\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass RectangleRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: RectangleRoi.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                },\n                initialRotation: 0\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const intermediate = {};\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            intermediate.x,\n            intermediate.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { finding, findingSites, cachedStats = {}, handles } = tool;\n        const { start, end } = handles;\n        const points = [\n            start,\n            { x: start.x, y: end.y },\n            end,\n            { x: end.x, y: start.y }\n        ];\n        const { area, perimeter } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:RectangleRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === RectangleRoi.toolType;\n};\n\nMeasurementReport.registerTool(RectangleRoi);\n\nexport default RectangleRoi;\n","import { log, utilities, normalizers, derivations } from \"dcmjs\";\nimport ndarray from \"ndarray\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D\n} = utilities.orientation;\n\nconst { datasetToBlob, BitArray, DicomMessage, DicomMetaDictionary } =\n    utilities;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState\n};\n\nexport default Segmentation;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(\n    images,\n    brushData,\n    options = { includeSliceSpacing: true }\n) {\n    const { toolState, segments } = brushData;\n\n    // Calculate the dimensions of the data cube.\n    const image0 = images[0];\n\n    const dims = {\n        x: image0.columns,\n        y: image0.rows,\n        z: images.length\n    };\n\n    dims.xy = dims.x * dims.y;\n\n    const numSegments = _getSegCount(seg, segments);\n\n    if (!numSegments) {\n        throw new Error(\"No segments to export!\");\n    }\n\n    const isMultiframe = image0.imageId.includes(\"?frame\");\n    const seg = _createSegFromImages(images, isMultiframe, options);\n\n    const { referencedFramesPerSegment, segmentIndicies } =\n        _getNumberOfFramesPerSegment(toolState, images, segments);\n\n    let NumberOfFrames = 0;\n\n    for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n        NumberOfFrames += referencedFramesPerSegment[i].length;\n    }\n\n    seg.setNumberOfFrames(NumberOfFrames);\n\n    for (let i = 0; i < segmentIndicies.length; i++) {\n        const segmentIndex = segmentIndicies[i];\n        const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n            return element + 1;\n        });\n\n        const segment = segments[segmentIndex];\n\n        seg.addSegment(\n            segment,\n            _extractCornerstoneToolsPixelData(\n                segmentIndex,\n                referencedFrameIndicies,\n                toolState,\n                images,\n                dims\n            ),\n            referencedFrameNumbers\n        );\n    }\n\n    seg.bitPackPixelData();\n\n    const segBlob = datasetToBlob(seg.dataset);\n\n    return segBlob;\n}\n\nfunction _extractCornerstoneToolsPixelData(\n    segmentIndex,\n    referencedFrames,\n    toolState,\n    images,\n    dims\n) {\n    const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n\n    let pixelDataIndex = 0;\n\n    for (let i = 0; i < referencedFrames.length; i++) {\n        const frame = referencedFrames[i];\n\n        const imageId = images[frame].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        const brushPixelData =\n            imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n\n        for (let p = 0; p < brushPixelData.length; p++) {\n            pixelData[pixelDataIndex] = brushPixelData[p];\n            pixelDataIndex++;\n        }\n    }\n\n    return pixelData;\n}\n\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n    const segmentIndicies = [];\n    const referencedFramesPerSegment = [];\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            segmentIndicies.push(i);\n            referencedFramesPerSegment.push([]);\n        }\n    }\n\n    for (let z = 0; z < images.length; z++) {\n        const imageId = images[z].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        for (let i = 0; i < segmentIndicies.length; i++) {\n            const segIdx = segmentIndicies[i];\n\n            if (\n                imageIdSpecificToolState &&\n                imageIdSpecificToolState.brush &&\n                imageIdSpecificToolState.brush.data &&\n                imageIdSpecificToolState.brush.data[segIdx] &&\n                imageIdSpecificToolState.brush.data[segIdx].pixelData\n            ) {\n                referencedFramesPerSegment[i].push(z);\n            }\n        }\n    }\n\n    return {\n        referencedFramesPerSegment,\n        segmentIndicies\n    };\n}\n\nfunction _getSegCount(seg, segments) {\n    let numSegments = 0;\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            numSegments++;\n        }\n    }\n\n    return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const SharedFunctionalGroupsSequence =\n        multiframe.SharedFunctionalGroupsSequence;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe);\n    const pixelData = unpackPixelData(multiframe);\n\n    const PerFrameFunctionalGroupsSequence =\n        multiframe.PerFrameFunctionalGroupsSequence;\n\n    const toolState = {};\n\n    let inPlane = true;\n\n    for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n\n        const ImageOrientationPatientI =\n            sharedImageOrientationPatient ||\n            PerFrameFunctionalGroups.PlaneOrientationSequence\n                .ImageOrientationPatient;\n\n        const pixelDataI2D = ndarray(\n            new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength),\n            [multiframe.Rows, multiframe.Columns]\n        );\n\n        const alignedPixelDataI = alignPixelDataWithSourceData(\n            pixelDataI2D,\n            ImageOrientationPatientI,\n            validOrientations\n        );\n\n        if (!alignedPixelDataI) {\n            console.warn(\n                \"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \"\n            );\n            inPlane = false;\n            break;\n        }\n\n        const segmentIndex =\n            PerFrameFunctionalGroups.SegmentIdentificationSequence\n                .ReferencedSegmentNumber - 1;\n\n        let SourceImageSequence;\n        if (\n            SharedFunctionalGroupsSequence.DerivationImageSequence &&\n            SharedFunctionalGroupsSequence.DerivationImageSequence\n                .SourceImageSequence\n        ) {\n            SourceImageSequence =\n                SharedFunctionalGroupsSequence.DerivationImageSequence\n                    .SourceImageSequence[i];\n        } else {\n            SourceImageSequence =\n                PerFrameFunctionalGroups.DerivationImageSequence\n                    .SourceImageSequence;\n        }\n\n        const imageId = getImageIdOfSourceImage(\n            SourceImageSequence,\n            imageIds,\n            metadataProvider\n        );\n\n        addImageIdSpecificBrushToolState(\n            toolState,\n            imageId,\n            segmentIndex,\n            alignedPixelDataI\n        );\n    }\n\n    if (!inPlane) {\n        return;\n    }\n\n    return { toolState, segMetadata };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n    const segType = multiframe.SegmentationType;\n\n    if (segType === \"BINARY\") {\n        return BitArray.unpack(multiframe.PixelData);\n    }\n\n    const pixelData = new Uint8Array(multiframe.PixelData);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        log.warn(\n            \"This is a fractional segmentation, which is not currently supported.\"\n        );\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(\n    toolState,\n    imageId,\n    segmentIndex,\n    pixelData2D\n) {\n    if (!toolState[imageId]) {\n        toolState[imageId] = {};\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush) {\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush.data) {\n        toolState[imageId].brush.data = [];\n    }\n\n    toolState[imageId].brush.data[segmentIndex] = {};\n\n    const brushDataI = toolState[imageId].brush.data[segmentIndex];\n\n    brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n\n    const cToolsPixelData = brushDataI.pixelData;\n\n    for (let p = 0; p < cToolsPixelData.length; p++) {\n        if (pixelData2D.data[p]) {\n            cToolsPixelData[p] = 1;\n        } else {\n            cToolsPixelData[p] = 0;\n        }\n    }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(\n    SourceImageSequence,\n    imageIds,\n    metadataProvider\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              imageIds,\n              metadataProvider\n          )\n        : getImageIdOfReferencedSingleFramedSOPInstance(\n              ReferencedSOPInstanceUID,\n              imageIds,\n              metadataProvider\n          );\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(\n    sopInstanceUid,\n    imageIds,\n    metadataProvider\n) {\n    return imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\n    });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    imageIds,\n    metadataProvider\n) {\n    const imageId = imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n        return (\n            //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n            sopCommonModule.sopInstanceUID === sopInstanceUid &&\n            imageIdFrameNumber === frameNumber - 1\n        );\n    });\n\n    return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n    if (compareIOP(iop, orientations[0])) {\n        //Same orientation.\n        return pixelData2D;\n    } else if (compareIOP(iop, orientations[1])) {\n        //Flipped vertically.\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareIOP(iop, orientations[2])) {\n        //Flipped horizontally.\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareIOP(iop, orientations[3])) {\n        //Rotated 90 degrees.\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareIOP(iop, orientations[4])) {\n        //Rotated 90 degrees and fliped horizontally.\n        return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[5])) {\n        //Rotated 90 degrees and fliped vertically.\n        return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[6])) {\n        //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[7])) {\n        //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n    return (\n        Math.abs(iop1[0] - iop2[0]) < dx &&\n        Math.abs(iop1[1] - iop2[1]) < dx &&\n        Math.abs(iop1[2] - iop2[2]) < dx &&\n        Math.abs(iop1[3] - iop2[3]) < dx &&\n        Math.abs(iop1[4] - iop2[4]) < dx &&\n        Math.abs(iop1[5] - iop2[5]) < dx\n    );\n}\n\nfunction getSegmentMetadata(multiframe) {\n    const data = [];\n\n    const segmentSequence = multiframe.SegmentSequence;\n\n    if (Array.isArray(segmentSequence)) {\n        for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n            data.push(segmentSequence[segIdx]);\n        }\n    } else {\n        // Only one segment, will be stored as an object.\n        data.push(segmentSequence);\n    }\n\n    return {\n        seriesInstanceUid:\n            multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n        data\n    };\n}\n","/**\n * Cornerstone adapters events\n */\nenum Events {\n    /**\n     * Cornerstone segmentation load progress event\n     */\n    SEGMENTATION_LOAD_PROGRESS = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\"\n}\n\nexport default Events;\n","import {\n    log,\n    data as dcmjsData,\n    utilities,\n    normalizers,\n    derivations\n} from \"dcmjs\";\nimport ndarray from \"ndarray\";\nimport cloneDeep from \"lodash.clonedeep\";\nimport { Buffer } from \"buffer\";\n\nimport { Events } from \"../enums\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D,\n    nearlyEqual\n} = utilities.orientation;\n\nconst { datasetToDict, BitArray, DicomMessage, DicomMetaDictionary } =\n    dcmjsData;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst { encode, decode } = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n    includeSliceSpacing: true,\n    rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D, userOptions = {}) {\n    const isMultiframe = images[0].imageId.includes(\"?frame\");\n    const segmentation = _createSegFromImages(\n        images,\n        isMultiframe,\n        userOptions\n    );\n\n    return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D, userOptions = {}) {\n    const options = Object.assign(\n        {},\n        generateSegmentationDefaultOptions,\n        userOptions\n    );\n\n    // Use another variable so we don't redefine labelmaps3D.\n    const labelmaps3D = Array.isArray(inputLabelmaps3D)\n        ? inputLabelmaps3D\n        : [inputLabelmaps3D];\n\n    let numberOfFrames = 0;\n    const referencedFramesPerLabelmap = [];\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { labelmaps2D, metadata } = labelmap3D;\n\n        const referencedFramesPerSegment = [];\n\n        for (let i = 1; i < metadata.length; i++) {\n            if (metadata[i]) {\n                referencedFramesPerSegment[i] = [];\n            }\n        }\n\n        for (let i = 0; i < labelmaps2D.length; i++) {\n            const labelmap2D = labelmaps2D[i];\n\n            if (labelmaps2D[i]) {\n                const { segmentsOnLabelmap } = labelmap2D;\n\n                segmentsOnLabelmap.forEach(segmentIndex => {\n                    if (segmentIndex !== 0) {\n                        referencedFramesPerSegment[segmentIndex].push(i);\n                        numberOfFrames++;\n                    }\n                });\n            }\n        }\n\n        referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n    }\n\n    segmentation.setNumberOfFrames(numberOfFrames);\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const referencedFramesPerSegment =\n            referencedFramesPerLabelmap[labelmapIndex];\n\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { metadata } = labelmap3D;\n\n        for (\n            let segmentIndex = 1;\n            segmentIndex < referencedFramesPerSegment.length;\n            segmentIndex++\n        ) {\n            const referencedFrameIndicies =\n                referencedFramesPerSegment[segmentIndex];\n\n            if (referencedFrameIndicies) {\n                // Frame numbers start from 1.\n                const referencedFrameNumbers = referencedFrameIndicies.map(\n                    element => {\n                        return element + 1;\n                    }\n                );\n                const segmentMetadata = metadata[segmentIndex];\n                const labelmaps = _getLabelmapsFromReferencedFrameIndicies(\n                    labelmap3D,\n                    referencedFrameIndicies\n                );\n\n                segmentation.addSegmentFromLabelmap(\n                    segmentMetadata,\n                    labelmaps,\n                    segmentIndex,\n                    referencedFrameNumbers\n                );\n            }\n        }\n    }\n    if (options.rleEncode) {\n        const rleEncodedFrames = encode(\n            segmentation.dataset.PixelData,\n            numberOfFrames,\n            segmentation.dataset.Rows,\n            segmentation.dataset.Columns\n        );\n\n        // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n        // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n        // added to the standard.\n        segmentation.assignToDataset({\n            BitsAllocated: \"8\",\n            BitsStored: \"8\",\n            HighBit: \"7\",\n            SegmentationType: \"FRACTIONAL\",\n            SegmentationFractionalType: \"PROBABILITY\",\n            MaximumFractionalValue: \"255\"\n        });\n\n        segmentation.dataset._meta.TransferSyntaxUID = {\n            Value: [\"1.2.840.10008.1.2.5\"],\n            vr: \"UI\"\n        };\n        segmentation.dataset._vrMap.PixelData = \"OB\";\n        segmentation.dataset.PixelData = rleEncodedFrames;\n    } else {\n        // If no rleEncoding, at least bitpack the data.\n        segmentation.bitPackPixelData();\n    }\n\n    const buffer = Buffer.from(datasetToDict(segmentation.dataset).write());\n    const segBlob = new Blob([buffer], { type: \"application/dicom\" });\n\n    return segBlob;\n}\n\nfunction _getLabelmapsFromReferencedFrameIndicies(\n    labelmap3D,\n    referencedFrameIndicies\n) {\n    const { labelmaps2D } = labelmap3D;\n\n    const labelmaps = [];\n\n    for (let i = 0; i < referencedFrameIndicies.length; i++) {\n        const frame = referencedFrameIndicies[i];\n\n        labelmaps.push(labelmaps2D[frame].pixelData);\n    }\n\n    return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds - An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    options\n) {\n    const {\n        skipOverlapping = false,\n        tolerance = 1e-3,\n        TypedArrayConstructor = Uint8Array,\n        maxBytesPerChunk = 199000000,\n        eventTarget,\n        triggerEvent\n    } = options;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    const generalSeriesModule = metadataProvider.get(\n        \"generalSeriesModule\",\n        imageIds[0]\n    );\n\n    const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n\n    const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n\n    let pixelData;\n    let pixelDataChunks;\n\n    if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n        const rleEncodedFrames = Array.isArray(multiframe.PixelData)\n            ? multiframe.PixelData\n            : [multiframe.PixelData];\n\n        pixelData = decode(\n            rleEncodedFrames,\n            multiframe.Rows,\n            multiframe.Columns\n        );\n\n        if (multiframe.BitsStored === 1) {\n            console.warn(\"No implementation for rle + bitbacking.\");\n\n            return;\n        }\n\n        // Todo: need to test this with rle data\n        pixelDataChunks = [pixelData];\n    } else {\n        pixelDataChunks = unpackPixelData(multiframe, { maxBytesPerChunk });\n\n        if (!pixelDataChunks) {\n            throw new Error(\"Fractional segmentations are not yet supported\");\n        }\n    }\n\n    const orientation = checkOrientation(\n        multiframe,\n        validOrientations,\n        [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length],\n        tolerance\n    );\n\n    // Pre-compute the sop UID to imageId index map so that in the for loop\n    // we don't have to call metadataProvider.get() for each imageId over\n    // and over again.\n    const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n        const { sopInstanceUid } = metadataProvider.get(\n            \"generalImageModule\",\n            imageId\n        );\n        acc[sopInstanceUid] = imageId;\n        return acc;\n    }, {});\n\n    let overlapping = false;\n    if (!skipOverlapping) {\n        overlapping = checkSEGsOverlapping(\n            pixelDataChunks,\n            multiframe,\n            imageIds,\n            validOrientations,\n            metadataProvider,\n            tolerance,\n            TypedArrayConstructor,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    let insertFunction;\n\n    switch (orientation) {\n        case \"Planar\":\n            if (overlapping) {\n                insertFunction = insertOverlappingPixelDataPlanar;\n            } else {\n                insertFunction = insertPixelDataPlanar;\n            }\n            break;\n        case \"Perpendicular\":\n            //insertFunction = insertPixelDataPerpendicular;\n            throw new Error(\n                \"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\"\n            );\n        case \"Oblique\":\n            throw new Error(\n                \"Segmentations oblique to the acquisition plane of the source data are not yet supported.\"\n            );\n    }\n\n    /* if SEGs are overlapping:\n    1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n    2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n    3) insertFunction will return the number of LabelMaps\n    4) generateToolState return is an array*/\n\n    const segmentsOnFrameArray = [];\n    segmentsOnFrameArray[0] = [];\n    const segmentsOnFrame = [];\n\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    const labelmapBufferArray = [];\n    labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n    // Precompute the indices and metadata so that we don't have to call\n    // a function for each imageId in the for loop.\n    const imageIdMaps = imageIds.reduce(\n        (acc, curr, index) => {\n            acc.indices[curr] = index;\n            acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n            return acc;\n        },\n        { indices: {}, metadata: {} }\n    );\n\n    // This is the centroid calculation for each segment Index, the data structure\n    // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n    // later on we will use this data structure to calculate the centroid of the\n    // segment in the labelmapBuffer\n    const segmentsPixelIndices = new Map();\n\n    await insertFunction(\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        labelmapBufferArray,\n        pixelDataChunks,\n        multiframe,\n        imageIds,\n        validOrientations,\n        metadataProvider,\n        tolerance,\n        TypedArrayConstructor,\n        segmentsPixelIndices,\n        sopUIDImageIdIndexMap,\n        imageIdMaps,\n        eventTarget,\n        triggerEvent\n    );\n\n    // calculate the centroid of each segment\n    const centroidXYZ = new Map();\n\n    segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n        const { xAcc, yAcc, zAcc, count } = calculateCentroid(\n            imageIdIndexBufferIndex,\n            multiframe\n        );\n\n        centroidXYZ.set(segmentIndex, {\n            x: Math.floor(xAcc / count),\n            y: Math.floor(yAcc / count),\n            z: Math.floor(zAcc / count)\n        });\n    });\n\n    return {\n        labelmapBufferArray,\n        segMetadata,\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        centroids: centroidXYZ\n    };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(\n    multiframe,\n    frameSegment,\n    imageIds,\n    metadataProvider,\n    tolerance,\n    sopUIDImageIdIndexMap\n) {\n    let imageId = undefined;\n\n    if (!multiframe) {\n        return imageId;\n    }\n\n    const {\n        FrameOfReferenceUID,\n        PerFrameFunctionalGroupsSequence,\n        SourceImageSequence,\n        ReferencedSeriesSequence\n    } = multiframe;\n\n    if (\n        !PerFrameFunctionalGroupsSequence ||\n        PerFrameFunctionalGroupsSequence.length === 0\n    ) {\n        return imageId;\n    }\n\n    const PerFrameFunctionalGroup =\n        PerFrameFunctionalGroupsSequence[frameSegment];\n\n    if (!PerFrameFunctionalGroup) {\n        return imageId;\n    }\n\n    let frameSourceImageSequence = undefined;\n    if (SourceImageSequence && SourceImageSequence.length !== 0) {\n        frameSourceImageSequence = SourceImageSequence[frameSegment];\n    } else if (PerFrameFunctionalGroup.DerivationImageSequence) {\n        let DerivationImageSequence =\n            PerFrameFunctionalGroup.DerivationImageSequence;\n        if (Array.isArray(DerivationImageSequence)) {\n            if (DerivationImageSequence.length !== 0) {\n                DerivationImageSequence = DerivationImageSequence[0];\n            } else {\n                DerivationImageSequence = undefined;\n            }\n        }\n\n        if (DerivationImageSequence) {\n            frameSourceImageSequence =\n                DerivationImageSequence.SourceImageSequence;\n            if (Array.isArray(frameSourceImageSequence)) {\n                if (frameSourceImageSequence.length !== 0) {\n                    frameSourceImageSequence = frameSourceImageSequence[0];\n                } else {\n                    frameSourceImageSequence = undefined;\n                }\n            }\n        }\n    }\n\n    if (frameSourceImageSequence) {\n        imageId = getImageIdOfSourceImageBySourceImageSequence(\n            frameSourceImageSequence,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    if (imageId === undefined && ReferencedSeriesSequence) {\n        const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence)\n            ? ReferencedSeriesSequence[0]\n            : ReferencedSeriesSequence;\n        const ReferencedSeriesInstanceUID =\n            referencedSeriesSequence.SeriesInstanceUID;\n\n        imageId = getImageIdOfSourceImagebyGeometry(\n            ReferencedSeriesInstanceUID,\n            FrameOfReferenceUID,\n            PerFrameFunctionalGroup,\n            imageIds,\n            metadataProvider,\n            tolerance\n        );\n    }\n\n    return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        SegmentSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    let numberOfSegs = SegmentSequence.length;\n    if (numberOfSegs < 2) {\n        return false;\n    }\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n    /** sort groupsLen to have all the segments for each frame in an array\n     * frame 2 : 1, 2\n     * frame 4 : 1, 3\n     * frame 5 : 4\n     */\n\n    let frameSegmentsMapping = new Map();\n    for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n        const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n        if (segmentIndex === undefined) {\n            console.warn(\n                \"Could not retrieve the segment index for frame segment \" +\n                    frameSegment +\n                    \", skipping this frame.\"\n            );\n            continue;\n        }\n\n        const imageId = findReferenceSourceImageId(\n            multiframe,\n            frameSegment,\n            imageIds,\n            metadataProvider,\n            tolerance,\n            sopUIDImageIdIndexMap\n        );\n\n        if (!imageId) {\n            console.warn(\n                \"Image not present in stack, can't import frame : \" +\n                    frameSegment +\n                    \".\"\n            );\n            continue;\n        }\n\n        const imageIdIndex = imageIds.findIndex(element => element === imageId);\n\n        if (frameSegmentsMapping.has(imageIdIndex)) {\n            let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n            if (!segmentArray.includes(frameSegment)) {\n                segmentArray.push(frameSegment);\n                frameSegmentsMapping.set(imageIdIndex, segmentArray);\n            }\n        } else {\n            frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n        }\n    }\n\n    for (let [, role] of frameSegmentsMapping.entries()) {\n        let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n\n        for (let i = 0; i < role.length; ++i) {\n            const frameSegment = role[i];\n\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[frameSegment];\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            const view = readFromUnpackedChunks(\n                pixelData,\n                frameSegment * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                console.warn(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\"\n                );\n                continue;\n            }\n\n            const data = alignedPixelDataI.data;\n            for (let j = 0, len = data.length; j < len; ++j) {\n                if (data[j] !== 0) {\n                    temp2DArray[j]++;\n                    if (temp2DArray[j] > 1) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction insertOverlappingPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    // indicate the number of labelMaps\n    let M = 1;\n\n    // indicate the current labelMap array index;\n    let m = 0;\n\n    // temp array for checking overlaps\n    let tempBuffer = labelmapBufferArray[m].slice(0);\n\n    // temp list for checking overlaps\n    let tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n\n    /** split overlapping SEGs algorithm for each segment:\n     *  A) copy the labelmapBuffer in the array with index 0\n     *  B) add the segment pixel per pixel on the copied buffer from (A)\n     *  C) if no overlap, copy the results back on the orignal array from (A)\n     *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n     */\n\n    let numberOfSegs = multiframe.SegmentSequence.length;\n    for (\n        let segmentIndexToProcess = 1;\n        segmentIndexToProcess <= numberOfSegs;\n        ++segmentIndexToProcess\n    ) {\n        for (\n            let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length;\n            i < groupsLen;\n            ++i\n        ) {\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[i];\n\n            const segmentIndex = getSegmentIndex(multiframe, i);\n            if (segmentIndex === undefined) {\n                throw new Error(\n                    \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                );\n            }\n\n            if (segmentIndex !== segmentIndexToProcess) {\n                continue;\n            }\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            // Since we moved to the chunks approach, we need to read the data\n            // and handle scenarios where the portion of data is in one chunk\n            // and the other portion is in another chunk\n            const view = readFromUnpackedChunks(\n                pixelData,\n                i * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                throw new Error(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                        \"This is not yet supported. Aborting segmentation loading.\"\n                );\n            }\n\n            const imageId = findReferenceSourceImageId(\n                multiframe,\n                i,\n                imageIds,\n                metadataProvider,\n                tolerance,\n                sopUIDImageIdIndexMap\n            );\n\n            if (!imageId) {\n                console.warn(\n                    \"Image not present in stack, can't import frame : \" +\n                        i +\n                        \".\"\n                );\n                continue;\n            }\n\n            const sourceImageMetadata = metadataProvider.get(\n                \"instance\",\n                imageId\n            );\n            if (\n                Rows !== sourceImageMetadata.Rows ||\n                Columns !== sourceImageMetadata.Columns\n            ) {\n                throw new Error(\n                    \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                        \"respect to the source image reference frame. This is not yet supported. \" +\n                        \"Aborting segmentation loading. \"\n                );\n            }\n\n            const imageIdIndex = imageIds.findIndex(\n                element => element === imageId\n            );\n            const byteOffset =\n                sliceLength *\n                imageIdIndex *\n                TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n            const labelmap2DView = new TypedArrayConstructor(\n                tempBuffer,\n                byteOffset,\n                sliceLength\n            );\n\n            const data = alignedPixelDataI.data;\n\n            let segmentOnFrame = false;\n            for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n                if (data[j]) {\n                    if (labelmap2DView[j] !== 0) {\n                        m++;\n                        if (m >= M) {\n                            labelmapBufferArray[m] = new ArrayBuffer(\n                                arrayBufferLength\n                            );\n                            segmentsOnFrameArray[m] = [];\n                            M++;\n                        }\n                        tempBuffer = labelmapBufferArray[m].slice(0);\n                        tempSegmentsOnFrame = cloneDeep(\n                            segmentsOnFrameArray[m]\n                        );\n\n                        i = 0;\n                        break;\n                    } else {\n                        labelmap2DView[j] = segmentIndex;\n                        segmentOnFrame = true;\n                    }\n                }\n            }\n\n            if (segmentOnFrame) {\n                if (!tempSegmentsOnFrame[imageIdIndex]) {\n                    tempSegmentsOnFrame[imageIdIndex] = [];\n                }\n\n                tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                if (!segmentsOnFrame[imageIdIndex]) {\n                    segmentsOnFrame[imageIdIndex] = [];\n                }\n\n                segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            }\n        }\n\n        labelmapBufferArray[m] = tempBuffer.slice(0);\n        segmentsOnFrameArray[m] = cloneDeep(tempSegmentsOnFrame);\n\n        // reset temp variables/buffers for new segment\n        m = 0;\n        tempBuffer = labelmapBufferArray[m].slice(0);\n        tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n    }\n}\n\nconst getSegmentIndex = (multiframe, frame) => {\n    const { PerFrameFunctionalGroupsSequence, SharedFunctionalGroupsSequence } =\n        multiframe;\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n    return PerFrameFunctionalGroups &&\n        PerFrameFunctionalGroups.SegmentIdentificationSequence\n        ? PerFrameFunctionalGroups.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n        ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : undefined;\n};\n\nfunction insertPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    eventTarget,\n    triggerEvent\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n\n    let i = 0;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n    const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n    const shouldTriggerEvent = triggerEvent && eventTarget;\n\n    // Below, we chunk the processing of the frames to avoid blocking the main thread\n    // if the segmentation is large. We also use a promise to allow the caller to\n    // wait for the processing to finish.\n    return new Promise(resolve => {\n        function processInChunks() {\n            // process one chunk\n            for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n                const PerFrameFunctionalGroups =\n                    PerFrameFunctionalGroupsSequence[i];\n\n                const ImageOrientationPatientI =\n                    sharedImageOrientationPatient ||\n                    PerFrameFunctionalGroups.PlaneOrientationSequence\n                        .ImageOrientationPatient;\n\n                const view = readFromUnpackedChunks(\n                    pixelData,\n                    i * sliceLength,\n                    sliceLength\n                );\n\n                const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n                const alignedPixelDataI = alignPixelDataWithSourceData(\n                    pixelDataI2D,\n                    ImageOrientationPatientI,\n                    validOrientations,\n                    tolerance\n                );\n\n                if (!alignedPixelDataI) {\n                    throw new Error(\n                        \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                            \"This is not yet supported. Aborting segmentation loading.\"\n                    );\n                }\n\n                const segmentIndex = getSegmentIndex(multiframe, i);\n\n                if (segmentIndex === undefined) {\n                    throw new Error(\n                        \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                    );\n                }\n\n                if (!segmentsPixelIndices.has(segmentIndex)) {\n                    segmentsPixelIndices.set(segmentIndex, {});\n                }\n\n                const imageId = findReferenceSourceImageId(\n                    multiframe,\n                    i,\n                    imageIds,\n                    metadataProvider,\n                    tolerance,\n                    sopUIDImageIdIndexMap\n                );\n\n                if (!imageId) {\n                    console.warn(\n                        \"Image not present in stack, can't import frame : \" +\n                            i +\n                            \".\"\n                    );\n                    continue;\n                }\n\n                const sourceImageMetadata = imageIdMaps.metadata[imageId];\n                if (\n                    Rows !== sourceImageMetadata.Rows ||\n                    Columns !== sourceImageMetadata.Columns\n                ) {\n                    throw new Error(\n                        \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                            \"respect to the source image reference frame. This is not yet supported. \" +\n                            \"Aborting segmentation loading. \"\n                    );\n                }\n\n                const imageIdIndex = imageIdMaps.indices[imageId];\n\n                const byteOffset =\n                    sliceLength *\n                    imageIdIndex *\n                    TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n                const labelmap2DView = new TypedArrayConstructor(\n                    labelmapBufferArray[0],\n                    byteOffset,\n                    sliceLength\n                );\n\n                const data = alignedPixelDataI.data;\n\n                const indexCache = [];\n                for (\n                    let j = 0, len = alignedPixelDataI.data.length;\n                    j < len;\n                    ++j\n                ) {\n                    if (data[j]) {\n                        for (let x = j; x < len; ++x) {\n                            if (data[x]) {\n                                labelmap2DView[x] = segmentIndex;\n                                indexCache.push(x);\n                            }\n                        }\n\n                        if (!segmentsOnFrame[imageIdIndex]) {\n                            segmentsOnFrame[imageIdIndex] = [];\n                        }\n\n                        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                        break;\n                    }\n                }\n\n                const segmentIndexObject =\n                    segmentsPixelIndices.get(segmentIndex);\n                segmentIndexObject[imageIdIndex] = indexCache;\n                segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n            }\n\n            // trigger an event after each chunk\n            if (shouldTriggerEvent) {\n                const percentComplete = Math.round((i / groupsLen) * 100);\n                triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n                    percentComplete\n                });\n            }\n\n            // schedule next chunk\n            if (i < groupsLen) {\n                setTimeout(processInChunks, 0);\n            } else {\n                // resolve the Promise when all chunks have been processed\n                resolve();\n            }\n        }\n\n        processInChunks();\n    });\n}\n\nfunction checkOrientation(\n    multiframe,\n    validOrientations,\n    sourceDataDimensions,\n    tolerance\n) {\n    const { SharedFunctionalGroupsSequence, PerFrameFunctionalGroupsSequence } =\n        multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    // Check if in plane.\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n\n    const iop =\n        sharedImageOrientationPatient ||\n        PerFrameFunctionalGroups.PlaneOrientationSequence\n            .ImageOrientationPatient;\n\n    const inPlane = validOrientations.some(operation =>\n        compareArrays(iop, operation, tolerance)\n    );\n\n    if (inPlane) {\n        return \"Planar\";\n    }\n\n    if (\n        checkIfPerpendicular(iop, validOrientations[0], tolerance) &&\n        sourceDataDimensions.includes(multiframe.Rows) &&\n        sourceDataDimensions.includes(multiframe.Columns)\n    ) {\n        // Perpendicular and fits on same grid.\n        return \"Perpendicular\";\n    }\n\n    return \"Oblique\";\n}\n\n/**\n * checkIfPerpendicular - Returns true if iop1 and iop2 are perpendicular\n * within a tolerance.\n *\n * @param  {Number[6]} iop1 An ImageOrientationPatient array.\n * @param  {Number[6]} iop2 An ImageOrientationPatient array.\n * @param  {Number} tolerance.\n * @return {Boolean} True if iop1 and iop2 are equal.\n */\nfunction checkIfPerpendicular(iop1, iop2, tolerance) {\n    const absDotColumnCosines = Math.abs(\n        iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]\n    );\n    const absDotRowCosines = Math.abs(\n        iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]\n    );\n\n    return (\n        (absDotColumnCosines < tolerance ||\n            Math.abs(absDotColumnCosines - 1) < tolerance) &&\n        (absDotRowCosines < tolerance ||\n            Math.abs(absDotRowCosines - 1) < tolerance)\n    );\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n    const segType = multiframe.SegmentationType;\n\n    let data;\n    if (Array.isArray(multiframe.PixelData)) {\n        data = multiframe.PixelData[0];\n    } else {\n        data = multiframe.PixelData;\n    }\n\n    if (data === undefined) {\n        log.error(\"This segmentation pixeldata is undefined.\");\n    }\n\n    if (segType === \"BINARY\") {\n        // For extreme big data, we can't unpack the data at once and we need to\n        // chunk it and unpack each chunk separately.\n        // MAX 2GB is the limit right now to allocate a buffer\n        return getUnpackedChunks(data, options.maxBytesPerChunk);\n    }\n\n    const pixelData = new Uint8Array(data);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        // This is a fractional segmentation, which is not currently supported.\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n    var bitArray = new Uint8Array(data);\n    var chunks = [];\n\n    var maxBitsPerChunk = maxBytesPerChunk * 8;\n    var numberOfChunks = Math.ceil((bitArray.length * 8) / maxBitsPerChunk);\n\n    for (var i = 0; i < numberOfChunks; i++) {\n        var startBit = i * maxBitsPerChunk;\n        var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n\n        var startByte = Math.floor(startBit / 8);\n        var endByte = Math.ceil(endBit / 8);\n\n        var chunk = bitArray.slice(startByte, endByte);\n        var unpackedChunk = BitArray.unpack(chunk);\n\n        chunks.push(unpackedChunk);\n    }\n\n    return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(\n    SourceImageSequence,\n    sopUIDImageIdIndexMap\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              sopUIDImageIdIndexMap\n          )\n        : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(\n    ReferencedSeriesInstanceUID,\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroup,\n    imageIds,\n    metadataProvider,\n    tolerance\n) {\n    if (\n        ReferencedSeriesInstanceUID === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0]\n            .ImagePositionPatient === undefined\n    ) {\n        return undefined;\n    }\n\n    for (\n        let imageIdsIndexc = 0;\n        imageIdsIndexc < imageIds.length;\n        ++imageIdsIndexc\n    ) {\n        const sourceImageMetadata = metadataProvider.get(\n            \"instance\",\n            imageIds[imageIdsIndexc]\n        );\n\n        if (\n            sourceImageMetadata === undefined ||\n            sourceImageMetadata.ImagePositionPatient === undefined ||\n            sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID ||\n            sourceImageMetadata.SeriesInstanceUID !==\n                ReferencedSeriesInstanceUID\n        ) {\n            continue;\n        }\n\n        if (\n            compareArrays(\n                PerFrameFunctionalGroup.PlanePositionSequence[0]\n                    .ImagePositionPatient,\n                sourceImageMetadata.ImagePositionPatient,\n                tolerance\n            )\n        ) {\n            return imageIds[imageIdsIndexc];\n        }\n    }\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    sopUIDImageIdIndexMap\n) {\n    const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n\n    if (!imageId) {\n        return;\n    }\n\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n    return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(\n    pixelData2D,\n    iop,\n    orientations,\n    tolerance\n) {\n    if (compareArrays(iop, orientations[0], tolerance)) {\n        return pixelData2D;\n    } else if (compareArrays(iop, orientations[1], tolerance)) {\n        // Flipped vertically.\n\n        // Undo Flip\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareArrays(iop, orientations[2], tolerance)) {\n        // Flipped horizontally.\n\n        // Unfo flip\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareArrays(iop, orientations[3], tolerance)) {\n        //Rotated 90 degrees\n\n        // Rotate back\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareArrays(iop, orientations[4], tolerance)) {\n        //Rotated 90 degrees and fliped horizontally.\n\n        // Undo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n    } else if (compareArrays(iop, orientations[5], tolerance)) {\n        // Rotated 90 degrees and fliped vertically\n\n        // Unfo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n    } else if (compareArrays(iop, orientations[6], tolerance)) {\n        // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareArrays(iop, orientations[7], tolerance)) {\n        // Rotated 270 degrees\n\n        // Rotate back.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\n/**\n * compareArrays - Returns true if array1 and array2 are equal\n * within a tolerance.\n *\n * @param  {Number[]} array1 - An array.\n * @param  {Number[]} array2 - An array.\n * @param {Number} tolerance.\n * @return {Boolean} True if array1 and array2 are equal.\n */\nfunction compareArrays(array1, array2, tolerance) {\n    if (array1.length != array2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < array1.length; ++i) {\n        if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n    const segmentSequence = multiframe.SegmentSequence;\n    let data = [];\n\n    if (Array.isArray(segmentSequence)) {\n        data = [undefined, ...segmentSequence];\n    } else {\n        // Only one segment, will be stored as an object.\n        data = [undefined, segmentSequence];\n    }\n\n    return {\n        seriesInstanceUid,\n        data\n    };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n    const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n    // If all the data is in one chunk, we can just slice that chunk\n    if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n        return new Uint8Array(\n            chunks[mapping.start.chunkIndex].buffer,\n            mapping.start.offset,\n            length\n        );\n    } else {\n        // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n        let result = new Uint8Array(length);\n        let resultOffset = 0;\n\n        for (\n            let i = mapping.start.chunkIndex;\n            i <= mapping.end.chunkIndex;\n            i++\n        ) {\n            let start =\n                i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n            let end =\n                i === mapping.end.chunkIndex\n                    ? mapping.end.offset\n                    : chunks[i].length;\n\n            result.set(\n                new Uint8Array(chunks[i].buffer, start, end - start),\n                resultOffset\n            );\n            resultOffset += end - start;\n        }\n\n        return result;\n    }\n}\n\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n    var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n\n    if (offset < 0 || offset + length > totalBytes) {\n        throw new Error(\"Offset and length out of bounds\");\n    }\n\n    var startChunkIndex = 0;\n    var startOffsetInChunk = offset;\n\n    while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n        startOffsetInChunk -= chunks[startChunkIndex].length;\n        startChunkIndex++;\n    }\n\n    var endChunkIndex = startChunkIndex;\n    var endOffsetInChunk = startOffsetInChunk + length;\n\n    while (endOffsetInChunk > chunks[endChunkIndex].length) {\n        endOffsetInChunk -= chunks[endChunkIndex].length;\n        endChunkIndex++;\n    }\n\n    return {\n        start: { chunkIndex: startChunkIndex, offset: startOffsetInChunk },\n        end: { chunkIndex: endChunkIndex, offset: endOffsetInChunk }\n    };\n}\n\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe) {\n    let xAcc = 0;\n    let yAcc = 0;\n    let zAcc = 0;\n    let count = 0;\n\n    for (const [imageIdIndex, bufferIndices] of Object.entries(\n        imageIdIndexBufferIndex\n    )) {\n        const z = Number(imageIdIndex);\n\n        if (!bufferIndices || bufferIndices.length === 0) {\n            continue;\n        }\n\n        for (const bufferIndex of bufferIndices) {\n            const y = Math.floor(bufferIndex / multiframe.Rows);\n            const x = bufferIndex % multiframe.Rows;\n\n            xAcc += x;\n            yAcc += y;\n            zAcc += z;\n\n            count++;\n        }\n    }\n\n    return { xAcc, yAcc, zAcc, count };\n}\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import MeasurementReport from \"./MeasurementReport\";\nimport Length from \"./Length\";\nimport FreehandRoi from \"./FreehandRoi\";\nimport Bidirectional from \"./Bidirectional\";\nimport EllipticalRoi from \"./EllipticalRoi\";\nimport CircleRoi from \"./CircleRoi\";\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport CobbAngle from \"./CobbAngle\";\nimport Angle from \"./Angle\";\nimport RectangleRoi from \"./RectangleRoi\";\n// Segmentation\nimport Segmentation from \"./Segmentation\";\n\nconst CornerstoneSR = {\n    Length,\n    FreehandRoi,\n    Bidirectional,\n    EllipticalRoi,\n    CircleRoi,\n    ArrowAnnotate,\n    MeasurementReport,\n    CobbAngle,\n    Angle,\n    RectangleRoi\n};\n\nconst CornerstoneSEG = {\n    Segmentation\n};\n\nexport { CornerstoneSR, CornerstoneSEG };\n","import Segmentation_3X from \"./Segmentation_3X\";\nimport Segmentation_4X from \"./Segmentation_4X\";\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(\n    images,\n    labelmaps3DorBrushData,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider,\n            skipOverlapping,\n            tolerance\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider\n        );\n    }\n\n    console.warn(\n        `No generateToolState adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(\n    segmentation,\n    inputLabelmaps3D,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.fillSegmentation(\n            segmentation,\n            inputLabelmaps3D,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export default \"Cornerstone3DTools@^0.1.0\";\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\n\nconst CodingScheme = {\n    CodingSchemeDesignator,\n    codeValues: {\n        CORNERSTONEFREETEXT\n    }\n};\n\nexport default CodingScheme;\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { toArray, codeMeaningEquals } from \"../helpers\";\nimport Cornerstone3DCodingScheme from \"./CodingScheme\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode?) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass,\n    worldToImageCoords\n) {\n    const args = toolClass.getTID300RepresentationArguments(\n        tool,\n        worldToImageCoords\n    );\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(\n    toolType,\n    toolData,\n    ReferencedSOPSequence,\n    worldToImageCoords\n) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass,\n            worldToImageCoords\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    public static CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n    public static MEASUREMENT_BY_TOOLTYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\n    static getCornerstoneLabelFromDefaultState(defaultState) {\n        const { findingSites = [], finding } = defaultState;\n\n        const cornersoneFreeTextCodingValue =\n            Cornerstone3DCodingScheme.codeValues.CORNERSTONEFREETEXT;\n\n        const freeTextLabel = findingSites.find(\n            fs => fs.CodeValue === cornersoneFreeTextCodingValue\n        );\n\n        if (freeTextLabel) {\n            return freeTextLabel.CodeMeaning;\n        }\n\n        if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n            return finding.CodeMeaning;\n        }\n    }\n\n    static generateDatasetMeta() {\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        return _meta;\n    }\n\n    static generateDerivationSourceDataset = instance => {\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        const derivationSourceDataset = {\n            ...instance,\n            _meta: _meta,\n            _vrMap: _vrMap\n        };\n\n        return derivationSourceDataset;\n    };\n\n    static getSetupMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        metadata,\n        toolType\n    ) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const referencedImageId =\n            sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        const finding = findingGroup\n            ? addAccessors(findingGroup.ConceptCodeSequence)\n            : undefined;\n        const findingSites = findingSiteGroups.map(fsg => {\n            return addAccessors(fsg.ConceptCodeSequence);\n        });\n\n        const defaultState = {\n            description: undefined,\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            annotation: {\n                annotationUID: DicomMetaDictionary.uid(),\n                metadata: {\n                    toolName: toolType,\n                    referencedImageId,\n                    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n                    label: \"\"\n                },\n                data: undefined\n            },\n            finding,\n            findingSites\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n\n        defaultState.annotation.metadata.label =\n            MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n\n        return {\n            defaultState,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(\n        toolState,\n        metadataProvider,\n        worldToImageCoords,\n        options\n    ) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n        let allMeasurementGroups = [];\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n        */\n\n        const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n        const derivationSourceDatasets = [];\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const instance = metadataProvider.get(\"instance\", imageId);\n\n            const { sopInstanceUID, sopClassUID } = sopCommonModule;\n            const { SeriesInstanceUID: seriesInstanceUID } = instance;\n\n            sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] =\n                seriesInstanceUID;\n\n            if (\n                !derivationSourceDatasets.find(\n                    dsd => dsd.SeriesInstanceUID === seriesInstanceUID\n                )\n            ) {\n                // Entry not present for series, create one.\n                const derivationSourceDataset =\n                    MeasurementReport.generateDerivationSourceDataset(instance);\n\n                derivationSourceDatasets.push(derivationSourceDataset);\n            }\n\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopClassUID,\n                ReferencedSOPInstanceUID: sopInstanceUID,\n                ReferencedFrameNumber: undefined\n            };\n\n            if (\n                (instance &&\n                    instance.NumberOfFrames &&\n                    instance.NumberOfFrames > 1) ||\n                Normalizer.isMultiframeSOPClassUID(sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence,\n                    worldToImageCoords\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const tid1500MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        const report = new StructuredReport(derivationSourceDatasets, options);\n\n        const contentItem = tid1500MeasurementReport.contentItem(\n            derivationSourceDatasets,\n            { ...options, sopInstanceUIDsToSeriesInstanceUIDMap }\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     */\n    static generateToolState(\n        dataset,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata,\n        hooks\n    ) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            try {\n                const measurementGroupContentSequence = toArray(\n                    measurementGroup.ContentSequence\n                );\n\n                const TrackingIdentifierGroup =\n                    measurementGroupContentSequence.find(\n                        contentItem =>\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                            TRACKING_IDENTIFIER\n                    );\n\n                const TrackingIdentifierValue =\n                    TrackingIdentifierGroup.TextValue;\n\n                const toolClass =\n                    hooks?.getToolClass?.(\n                        measurementGroup,\n                        dataset,\n                        registeredToolClasses\n                    ) ||\n                    registeredToolClasses.find(tc =>\n                        tc.isValidCornerstoneTrackingIdentifier(\n                            TrackingIdentifierValue\n                        )\n                    );\n\n                if (toolClass) {\n                    const measurement = toolClass.getMeasurementData(\n                        measurementGroup,\n                        sopInstanceUIDToImageIdMap,\n                        imageToWorldCoords,\n                        metadata\n                    );\n\n                    console.log(`=== ${toolClass.toolType} ===`);\n                    console.log(measurement);\n\n                    measurementData[toolClass.toolType].push(measurement);\n                }\n            } catch (e) {\n                console.warn(\n                    \"Unable to generate tool state for\",\n                    measurementGroup,\n                    e\n                );\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    /**\n     * Register a new tool type.\n     * @param toolClass to perform I/O to DICOM for this tool\n     */\n    public static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport CodingScheme from \"./CodingScheme\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ARROW_ANNOTATE}`;\n\nconst { codeValues, CodingSchemeDesignator } = CodingScheme;\n\nclass ArrowAnnotate {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                ArrowAnnotate.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const text = defaultState.annotation.metadata.label;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        // Since the arrowAnnotate measurement is just a point, to generate the tool state\n        // we derive the second point based on the image size relative to the first point.\n        if (worldCoords.length === 1) {\n            const imagePixelModule = metadata.get(\n                \"imagePixelModule\",\n                referencedImageId\n            );\n\n            let xOffset = 10;\n            let yOffset = 10;\n\n            if (imagePixelModule) {\n                const { columns, rows } = imagePixelModule;\n                xOffset = columns / 10;\n                yOffset = rows / 10;\n            }\n\n            const secondPoint = imageToWorldCoords(referencedImageId, [\n                GraphicData[0] + xOffset,\n                GraphicData[1] + yOffset\n            ]);\n\n            worldCoords.push(secondPoint);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            text,\n            handles: {\n                arrowFirst: true,\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points, arrowFirst } = data.handles;\n\n        let point;\n\n        if (arrowFirst) {\n            point = points[0];\n        } else {\n            point = points[1];\n        }\n\n        const pointImage = worldToImageCoords(referencedImageId, point);\n\n        const TID300RepresentationArguments = {\n            points: [\n                {\n                    x: pointImage[0],\n                    y: pointImage[1]\n                }\n            ],\n            trackingIdentifierTextValue,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: codeValues.CORNERSTONEFREETEXT,\n                CodingSchemeDesignator,\n                CodeMeaning: data.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${BIDIRECTIONAL}`;\n\nclass Bidirectional {\n    public static toolType = BIDIRECTIONAL;\n    public static utilityToolType = BIDIRECTIONAL;\n    public static TID300Representation = TID300Bidirectional;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === BIDIRECTIONAL;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Bidirectional.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { ContentSequence } = MeasurementGroup;\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const worldCoords = [];\n\n        [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n            const { GraphicData } = group;\n            for (let i = 0; i < GraphicData.length; i += 2) {\n                const point = imageToWorldCoords(referencedImageId, [\n                    GraphicData[i],\n                    GraphicData[i + 1]\n                ]);\n                worldCoords.push(point);\n            }\n        });\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n                    width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { length, width } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const { points } = handles;\n\n        // Find the length and width point pairs by comparing the distances of the points at 0,1 to points at 2,3\n        const firstPointPairs = [points[0], points[1]];\n        const secondPointPairs = [points[2], points[3]];\n\n        const firstPointPairsDistance = Math.sqrt(\n            Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) +\n                Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) +\n                Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2)\n        );\n\n        const secondPointPairsDistance = Math.sqrt(\n            Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) +\n                Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) +\n                Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2)\n        );\n\n        let shortAxisPoints;\n        let longAxisPoints;\n        if (firstPointPairsDistance > secondPointPairsDistance) {\n            shortAxisPoints = firstPointPairs;\n            longAxisPoints = secondPointPairs;\n        } else {\n            shortAxisPoints = secondPointPairs;\n            longAxisPoints = firstPointPairs;\n        }\n\n        const longAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[0]\n        );\n        const longAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[1]\n        );\n        const shortAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[0]\n        );\n        const shortAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[1]\n        );\n\n        return {\n            longAxis: {\n                point1: {\n                    x: longAxisStartImage[0],\n                    y: longAxisStartImage[1]\n                },\n                point2: {\n                    x: longAxisEndImage[0],\n                    y: longAxisEndImage[1]\n                }\n            },\n            shortAxis: {\n                point1: {\n                    x: shortAxisStartImage[0],\n                    y: shortAxisStartImage[1]\n                },\n                point2: {\n                    x: shortAxisEndImage[0],\n                    y: shortAxisEndImage[1]\n                }\n            },\n            longAxisLength: length,\n            shortAxisLength: width,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"Angle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass Angle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Angle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Angle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const end = worldToImageCoords(referencedImageId, handles.points[2]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: middle[0], y: middle[1] };\n        const point3 = point2;\n        const point4 = { x: end[0], y: end[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        // Represented as a cobb angle\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"CobbAngle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass CobbAngle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CobbAngle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n        const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: end1[0], y: end1[1] };\n        const point3 = { x: start2[0], y: start2[1] };\n        const point4 = { x: end2[0], y: end2[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nexport default function isValidCornerstoneTrackingIdentifier(\n    trackingIdentifier: string\n): boolean {\n    if (!trackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = trackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    // The following is needed since the new cornerstone3D has changed\n    // case names such as EllipticalRoi to EllipticalROI\n    return toolType.toLowerCase() === this.toolType.toLowerCase();\n}\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleROI\";\n\nclass CircleROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${CIRCLEROI}`;\n    static toolType = CIRCLEROI;\n    static utilityToolType = CIRCLEROI;\n    static TID300Representation = TID300Circle;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CircleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [centerX, centerY, endX, endY]\n        const pointsWorld = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...pointsWorld],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0,\n                    // Dummy values to be updated by cornerstone\n                    radius: 0,\n                    perimeter: 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const center = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const points = [];\n        points.push({ x: center[0], y: center[1] });\n        points.push({ x: end[0], y: end[1] });\n\n        const { area, radius } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const perimeter = 2 * Math.PI * radius;\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CircleROI);\n\nexport default CircleROI;\n","import { vec3 } from \"gl-matrix\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\ntype Point3 = [number, number, number];\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalROI\";\nconst EPSILON = 1e-4;\n\nclass EllipticalROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ELLIPTICALROI}`;\n    static toolType = ELLIPTICALROI;\n    static utilityToolType = ELLIPTICALROI;\n    static TID300Representation = TID300Ellipse;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                EllipticalROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n        // But Cornerstone3D points are ordered as top, bottom, left, right for the\n        // ellipse so we need to identify if the majorAxis is horizontal or vertical\n        // in the image plane and then choose the correct points to use for the ellipse.\n        const pointsWorld: Point3[] = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n        const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n        const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n        const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n        const majorAxisVec = vec3.create();\n        vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n        // normalize majorAxisVec to avoid scaling issues\n        vec3.normalize(majorAxisVec, majorAxisVec);\n\n        const minorAxisVec = vec3.create();\n        vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n        vec3.normalize(minorAxisVec, minorAxisVec);\n\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        if (!imagePlaneModule) {\n            throw new Error(\"imageId does not have imagePlaneModule metadata\");\n        }\n\n        const { columnCosines } = imagePlaneModule;\n\n        // find which axis is parallel to the columnCosines\n        const columnCosinesVec = vec3.fromValues(\n            columnCosines[0],\n            columnCosines[1],\n            columnCosines[2]\n        );\n        const projectedMajorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            majorAxisVec\n        );\n\n        const projectedMinorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            minorAxisVec\n        );\n\n        const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n        const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n        let ellipsePoints = [];\n        if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[0],\n                pointsWorld[1],\n                pointsWorld[2],\n                pointsWorld[3]\n            ];\n        } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[2],\n                pointsWorld[3],\n                pointsWorld[0],\n                pointsWorld[1]\n            ];\n        } else {\n            console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...ellipsePoints],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n        const rotation = data.initialRotation || 0;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n        let top, bottom, left, right;\n        // this way when it's restored we can assume the initial rotation is 0.\n        if (rotation == 90 || rotation == 270) {\n            bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n            top = worldToImageCoords(referencedImageId, handles.points[3]);\n            left = worldToImageCoords(referencedImageId, handles.points[0]);\n            right = worldToImageCoords(referencedImageId, handles.points[1]);\n        } else {\n            top = worldToImageCoords(referencedImageId, handles.points[0]);\n            bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n            left = worldToImageCoords(referencedImageId, handles.points[2]);\n            right = worldToImageCoords(referencedImageId, handles.points[3]);\n        }\n\n        // find the major axis and minor axis\n        const topBottomLength = Math.abs(top[1] - bottom[1]);\n        const leftRightLength = Math.abs(left[0] - right[0]);\n\n        const points = [];\n        if (topBottomLength > leftRightLength) {\n            // major axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n\n            // minor axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n        } else {\n            // major axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n\n            // minor axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n        }\n\n        const { area } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(EllipticalROI);\n\nexport default EllipticalROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst TOOLTYPE = \"RectangleROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${TOOLTYPE}`;\n\nclass RectangleROI {\n    public static toolType = TOOLTYPE;\n    public static utilityToolType = TOOLTYPE;\n    public static TID300Representation = TID300Polyline;\n\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === TOOLTYPE;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                RectangleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[3],\n                    worldCoords[2]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const corners = handles.points.map(point =>\n            worldToImageCoords(referencedImageId, point)\n        );\n\n        const { area, perimeter } = cachedStats;\n\n        return {\n            points: [\n                corners[0],\n                corners[1],\n                corners[3],\n                corners[2],\n                corners[0]\n            ],\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(RectangleROI);\n\nexport default RectangleROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${LENGTH}`;\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Length.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Length.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const point1 = { x: start[0], y: start[1] };\n        const point2 = { x: end[0], y: end[1] };\n\n        const { length: distance } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { vec3 } from \"gl-matrix\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst PLANARFREEHANDROI = \"PlanarFreehandROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PLANARFREEHANDROI}`;\nconst closedContourThreshold = 1e-5;\n\nclass PlanarFreehandROI {\n    public static toolType = PLANARFREEHANDROI;\n    public static utilityToolType = PLANARFREEHANDROI;\n    public static TID300Representation = TID300Polyline;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === PLANARFREEHANDROI;\n    };\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                PlanarFreehandROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            worldCoords.push(point);\n        }\n\n        const distanceBetweenFirstAndLastPoint = vec3.distance(\n            worldCoords[worldCoords.length - 1],\n            worldCoords[0]\n        );\n\n        let isOpenContour = true;\n\n        // If the contour is closed, this should have been encoded as exactly the same point, so check for a very small difference.\n        if (distanceBetweenFirstAndLastPoint < closedContourThreshold) {\n            worldCoords.pop(); // Remove the last element which is duplicated.\n\n            isOpenContour = false;\n        }\n\n        const points = [];\n\n        if (isOpenContour) {\n            points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            polyline: worldCoords,\n            isOpenContour,\n            handles: {\n                points,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { isOpenContour, polyline } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const points = polyline.map(worldPos =>\n            worldToImageCoords(referencedImageId, worldPos)\n        );\n\n        if (!isOpenContour) {\n            // Need to repeat the first point at the end of to have an explicitly closed contour.\n            const firstPoint = points[0];\n\n            // Explicitly expand to avoid ciruclar references.\n            points.push([firstPoint[0], firstPoint[1]]);\n        }\n\n        const area = 0; // TODO -> The tool doesn't have these stats yet.\n        const perimeter = 0;\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(PlanarFreehandROI);\n\nexport default PlanarFreehandROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst PROBE = \"Probe\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PROBE}`;\n\nclass Probe {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Probe.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: worldCoords,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Probe.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points } = data.handles;\n\n        const pointsImage = points.map(point => {\n            const pointImage = worldToImageCoords(referencedImageId, point);\n            return {\n                x: pointImage[0],\n                y: pointImage[1]\n            };\n        });\n\n        const TID300RepresentationArguments = {\n            points: pointsImage,\n            trackingIdentifierTextValue,\n            findingSites: findingSites || [],\n            finding\n        };\n\n        return TID300RepresentationArguments;\n    }\n}\n\nProbe.toolType = PROBE;\nProbe.utilityToolType = PROBE;\nProbe.TID300Representation = TID300Point;\nProbe.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === PROBE;\n};\n\nMeasurementReport.registerTool(Probe);\n\nexport default Probe;\n","import { normalizers, derivations } from \"dcmjs\";\nimport { fillSegmentation } from \"../../Cornerstone/Segmentation_4X\";\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param images - An array of the cornerstone image objects, which includes imageId and metadata\n * @param labelmaps - An array of the 3D Volumes that contain the segmentation data.\n */\nfunction generateSegmentation(images, labelmaps, metadata, options) {\n    const segmentation = _createMultiframeSegmentationFromReferencedImages(\n        images,\n        metadata,\n        options\n    );\n    return fillSegmentation(segmentation, labelmaps, options);\n}\n\n/**\n * _createMultiframeSegmentationFromReferencedImages - description\n *\n * @param images - An array of the cornerstone image objects related to the reference\n * series that the segmentation is derived from. You can use methods such as\n * volume.getCornerstoneImages() to get this array.\n *\n * @param options - the options object for the SegmentationDerivation.\n * @returns The Seg derived dataSet.\n */\nfunction _createMultiframeSegmentationFromReferencedImages(\n    images,\n    metadata,\n    options\n) {\n    const datasets = images.map(image => {\n        // add the sopClassUID to the dataset\n        const instance = metadata.get(\"instance\", image.imageId);\n        return {\n            ...image,\n            ...instance,\n            // Todo: move to dcmjs tag style\n            SOPClassUID: instance.SopClassUID,\n            SOPInstanceUID: instance.SopInstanceUID,\n            PixelData: image.getPixelData(),\n            _vrMap: {\n                PixelData: \"OW\"\n            },\n            _meta: {}\n        };\n    });\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","import { CornerstoneSEG } from \"../../Cornerstone\";\n\nconst { Segmentation } = CornerstoneSEG;\nconst { generateToolState: generateToolStateCornerstoneLegacy } = Segmentation;\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param   imageIds - An array of the imageIds.\n * @param   arrayBuffer - The SEG arrayBuffer.\n * @param   skipOverlapping - skip checks for overlapping segs, default value false.\n * @param   tolerance - default value 1.e-3.\n *\n * @returns a list of array buffer for each labelMap\n *  an object from which the segment metadata can be derived\n *  list containing the track of segments per frame\n *  list containing the track of segments per frame for each labelMap                   (available only for the overlapping case).\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3\n) {\n    return generateToolStateCornerstoneLegacy(\n        imageIds,\n        arrayBuffer,\n        metadataProvider,\n        skipOverlapping,\n        tolerance\n    );\n}\n\nexport { generateToolState };\n","import MeasurementReport from \"./MeasurementReport\";\nimport CodeScheme from \"./CodingScheme\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport Bidirectional from \"./Bidirectional\";\nimport Angle from \"./Angle\";\nimport CobbAngle from \"./CobbAngle\";\nimport CircleROI from \"./CircleROI\";\nimport EllipticalROI from \"./EllipticalROI\";\nimport RectangleROI from \"./RectangleROI\";\nimport Length from \"./Length\";\nimport PlanarFreehandROI from \"./PlanarFreehandROI\";\nimport Probe from \"./Probe\";\nimport * as Segmentation from \"./Segmentation\";\n\nconst Cornerstone3DSR = {\n    Bidirectional,\n    CobbAngle,\n    Angle,\n    Length,\n    CircleROI,\n    EllipticalROI,\n    RectangleROI,\n    ArrowAnnotate,\n    Probe,\n    PlanarFreehandROI,\n    MeasurementReport,\n    CodeScheme,\n    CORNERSTONE_3D_TAG\n};\n\nconst Cornerstone3DSEG = {\n    Segmentation\n};\n\nexport { Cornerstone3DSR, Cornerstone3DSEG };\n","/**\n * Generates 2D label maps from a 3D label map.\n * @param labelmap3D - The 3D label map object to generate 2D label maps from. It is derived\n * from the volume labelmap.\n * @returns The label map object containing the 2D label maps and segments on label maps.\n */\nfunction generateLabelMaps2DFrom3D(labelmap3D): {\n    scalarData: number[];\n    dimensions: number[];\n    segmentsOnLabelmap: number[];\n    labelmaps2D: {\n        segmentsOnLabelmap: number[];\n        pixelData: number[];\n        rows: number;\n        columns: number;\n    }[];\n} {\n    // 1. we need to generate labelmaps2D from labelmaps3D, a labelmap2D is for each\n    // slice\n    const { scalarData, dimensions } = labelmap3D;\n\n    // scalarData is a flat array of all the pixels in the volume.\n    const labelmaps2D = [];\n    const segmentsOnLabelmap3D = new Set();\n\n    // X-Y are the row and column dimensions, Z is the number of slices.\n    for (let z = 0; z < dimensions[2]; z++) {\n        const pixelData = scalarData.slice(\n            z * dimensions[0] * dimensions[1],\n            (z + 1) * dimensions[0] * dimensions[1]\n        );\n\n        const segmentsOnLabelmap = [];\n\n        for (let i = 0; i < pixelData.length; i++) {\n            const segment = pixelData[i];\n            if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n                segmentsOnLabelmap.push(segment);\n            }\n        }\n\n        const labelmap2D = {\n            segmentsOnLabelmap,\n            pixelData,\n            rows: dimensions[1],\n            columns: dimensions[0]\n        };\n\n        if (segmentsOnLabelmap.length === 0) {\n            continue;\n        }\n\n        segmentsOnLabelmap.forEach(segmentIndex => {\n            segmentsOnLabelmap3D.add(segmentIndex);\n        });\n\n        labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n    }\n\n    // remove segment 0 from segmentsOnLabelmap3D\n    labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n\n    labelmap3D.labelmaps2D = labelmaps2D;\n\n    return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","import { data } from \"dcmjs\";\n\nconst { Colors, BitArray } = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n    const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n    rgba.push(255);\n\n    return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n    const Zx = x[1] * y[2] - x[2] * y[1];\n    const Zy = x[2] * y[0] - x[0] * y[2];\n    const Zz = x[0] * y[1] - x[1] * y[0];\n    out[0] = Zx;\n    out[1] = Zy;\n    out[2] = Zz;\n}\n\nfunction norm(x, n = 3) {\n    switch (n) {\n        case 1:\n            return Math.abs(x);\n        case 2:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n        case 3:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n        default: {\n            let sum = 0;\n            for (let i = 0; i < n; i++) {\n                sum += x[i] * x[i];\n            }\n            return Math.sqrt(sum);\n        }\n    }\n}\n\nfunction normalize(x) {\n    const den = norm(x);\n    if (den !== 0.0) {\n        x[0] /= den;\n        x[1] /= den;\n        x[2] /= den;\n    }\n    return den;\n}\n\nfunction subtract(a, b, out) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n    const geometry = {};\n    const pixelMeasures =\n        dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n    const planeOrientation =\n        dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n    // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n    //\n    // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n    // sort them to obtain the first and last position along the acquisition axis.\n    const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n    const lastFunctionalGroup =\n        PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n    const firstPosition =\n        firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n    const lastPosition =\n        lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n\n    geometry.origin = firstPosition;\n\n    // NB: DICOM PixelSpacing is defined as Row then Column,\n    // unlike ImageOrientationPatient\n    geometry.spacing = [\n        pixelMeasures.PixelSpacing[1],\n        pixelMeasures.PixelSpacing[0],\n        pixelMeasures.SpacingBetweenSlices\n    ].map(Number);\n\n    geometry.dimensions = [\n        dataset.Columns,\n        dataset.Rows,\n        PerFrameFunctionalGroups.length\n    ].map(Number);\n\n    const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n    const columnStepToPatient = orientation.slice(0, 3);\n    const rowStepToPatient = orientation.slice(3, 6);\n\n    geometry.planeNormal = [];\n\n    cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n\n    geometry.sliceStep = [];\n    subtract(lastPosition, firstPosition, geometry.sliceStep);\n    normalize(geometry.sliceStep);\n    geometry.direction = columnStepToPatient\n        .concat(rowStepToPatient)\n        .concat(geometry.sliceStep);\n\n    return geometry;\n}\n\nexport default class Segmentation {\n    constructor() {}\n\n    /**\n     * Produces an array of Segments from an input DICOM Segmentation dataset\n     *\n     * Segments are returned with Geometry values that can be used to create\n     * VTK Image Data objects.\n     *\n     * @example Example usage to create VTK Volume actors from each segment:\n     *\n     * const actors = [];\n     * const segments = generateToolState(dataset);\n     * segments.forEach(segment => {\n     *   // now make actors using the segment information\n     *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n     *        name: \"Scalars\",\n     *        numberOfComponents: 1,\n     *        values: segment.pixelData,\n     *    });\n     *\n     *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n     *    imageData.getPointData().setScalars(scalarArray);\n     *    imageData.setDimensions(geometry.dimensions);\n     *    imageData.setSpacing(geometry.spacing);\n     *    imageData.setOrigin(geometry.origin);\n     *    imageData.setDirection(geometry.direction);\n     *\n     *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n     *    mapper.setInputData(imageData);\n     *    mapper.setSampleDistance(2.);\n     *\n     *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n     *    actor.setMapper(mapper);\n     *\n     *    actors.push(actor);\n     * });\n     *\n     * @param dataset\n     * @return {{}}\n     */\n    static generateSegments(dataset) {\n        if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n            dataset.SegmentSequence = [dataset.SegmentSequence];\n        }\n\n        dataset.SegmentSequence.forEach(segment => {\n            // TODO: other interesting fields could be extracted from the segment\n            // TODO: Read SegmentsOverlay field\n            // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n            // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n            // Why was this example converting to RGBA with 0-255 values?\n            const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n\n            segments[segment.SegmentNumber] = {\n                color,\n                functionalGroups: [],\n                offset: null,\n                size: null,\n                pixelData: null\n            };\n        });\n\n        // make a list of functional groups per segment\n        dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n            const segmentNumber =\n                functionalGroup.SegmentIdentificationSequence\n                    .ReferencedSegmentNumber;\n\n            segments[segmentNumber].functionalGroups.push(functionalGroup);\n        });\n\n        // determine per-segment index into the pixel data\n        // TODO: only handles one-bit-per pixel\n        const frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\n        let nextOffset = 0;\n\n        Object.keys(segments).forEach(segmentNumber => {\n            const segment = segments[segmentNumber];\n\n            segment.numberOfFrames = segment.functionalGroups.length;\n            segment.size = segment.numberOfFrames * frameSize;\n            segment.offset = nextOffset;\n\n            nextOffset = segment.offset + segment.size;\n\n            const packedSegment = dataset.PixelData.slice(\n                segment.offset,\n                nextOffset\n            );\n\n            segment.pixelData = BitArray.unpack(packedSegment);\n\n            const geometry = geometryFromFunctionalGroups(\n                dataset,\n                segment.functionalGroups\n            );\n\n            segment.geometry = geometry;\n        });\n\n        return segments;\n    }\n}\n","import { CornerstoneSR } from \"./Cornerstone\";\nimport { Cornerstone3DSR, Cornerstone3DSEG } from \"./Cornerstone3D\";\nimport { VTKjsSEG } from \"./VTKjs\";\nimport * as Enums from \"./enums\";\nimport * as helpers from \"./helpers\";\n\nconst adaptersSR = {\n    Cornerstone: CornerstoneSR,\n    Cornerstone3D: Cornerstone3DSR\n};\n\nconst adaptersSEG = {\n    Cornerstone: CornerstoneSR,\n    Cornerstone3D: Cornerstone3DSEG,\n    VTKjs: VTKjsSEG\n};\n\nexport { adaptersSR, adaptersSEG, Enums, helpers };\n","import Segmentation from \"./Segmentation\";\n\nconst VTKjsSEG = {\n    Segmentation\n};\n\nexport { VTKjsSEG };\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":["toArray","x","Array","isArray","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","TID1500","utilities","addAccessors","StructuredReport","derivations","Normalizer","normalizers","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","data","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","MeasurementReport","_classCallCheck","_createClass","key","value","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPSequence","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","undefined","findingSites","map","fsg","description","findingSite","location","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","Error","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolData","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","toolType","toolTypeData","toolClass","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","length","Measurements","tool","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem","getMeasurementGroup","push","concat","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","_meta","FileMetaInformationVersion","Value","buffer","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","utilityToolType","MEASUREMENT_BY_TOOLTYPE","TID300Length","TID300","Length","LENGTH","_MeasurementReport$ge","getSetupMeasurementData","state","_objectSpread","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","_SCOORDGroup$GraphicD","_slicedToArray","GraphicData","y","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","_TrackingIdentifier$s2","split","cornerstone4Tag","CORNERSTONE_4_TAG","registerTool","TID300Polyline","Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","_tool$cachedStats","_cachedStats$area","_cachedStats$perimete","perimeter","TID300Bidirectional","Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","_tool$handles","longAxis","shortAxis","longAxisLength","shortAxisLength","TID300Ellipse","Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","TID300Circle","Circle","CIRCLEROI","CircleRoi","radius","PI","TID300Point","Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","text","TID300RepresentationArguments","TID300CobbAngle","CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","TID300Angle","Angle","ANGLE","middle","RectangleRoi","_utilities$orientatio","orientation","rotateDirectionCosinesInPlane","flipIOP","flipImageOrientationPatient","flipMatrix2D","rotateMatrix902D","datasetToBlob","BitArray","DicomMessage","SegmentationDerivation","Segmentation","generateSegmentation","images","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","_getSegCount","seg","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","multiframe","normalizeToDataset","_createSegFromImages","_getNumberOfFramesPer","segmentIndicies","referencedFramesPerSegment","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","generateToolState","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","_toConsumableArray","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","ndarray","SegmentIdentificationSequence","ReferencedSegmentNumber","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","DerivationImageSequence","SourceImageSequence","referencedFrames","pixelDataIndex","brushPixelData","p","numSegments","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","Events","dx","iop1","iop2","nearlyEqual","datasetToDict","dcmjsData","_utilities$compressio","compression","encode","decode","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","_loop","labelmap3D","labelmapIndex","labelmaps2D","metadata","_loop2","_i","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","Buffer","from","write","Blob","type","frame","_generateToolState","_regeneratorRuntime","mark","_callee","_options$skipOverlapp","skipOverlapping","_options$tolerance","tolerance","_options$TypedArrayCo","TypedArrayConstructor","_options$maxBytesPerC","maxBytesPerChunk","eventTarget","triggerEvent","pixelDataChunks","sopUIDImageIdIndexMap","overlapping","insertFunction","segmentsOnFrameArray","segmentsOnFrame","arrayBufferLength","labelmapBufferArray","imageIdMaps","segmentsPixelIndices","centroidXYZ","wrap","_context","prev","next","abrupt","checkOrientation","reduce","acc","checkSEGsOverlapping","t0","insertOverlappingPixelDataPlanar","insertPixelDataPlanar","BYTES_PER_ELEMENT","ArrayBuffer","curr","indices","Map","imageIdIndexBufferIndex","_calculateCentroid","calculateCentroid","xAcc","yAcc","zAcc","count","set","floor","centroids","stop","apply","findReferenceSourceImageId","frameSegment","FrameOfReferenceUID","PerFrameFunctionalGroup","frameSourceImageSequence","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","imageIdsIndexc","sourceImageMetadata","compareArrays","getImageIdOfSourceImagebyGeometry","groupsLen","frameSegmentsMapping","_loop3","getSegmentIndex","imageIdIndex","findIndex","has","segmentArray","_step","_iterator","_createForOfIteratorHelper","entries","s","n","done","role","temp2DArray","fill","view","readFromUnpackedChunks","j","len","err","e","f","M","m","tempBuffer","slice","tempSegmentsOnFrame","cloneDeep","numberOfSegs","segmentIndexToProcess","_loop4","_i2","byteOffset","labelmap2DView","segmentOnFrame","chunkSize","ceil","shouldTriggerEvent","Promise","resolve","processInChunks","min","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","sourceDataDimensions","some","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","error","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","endByte","chunk","unpackedChunk","getUnpackedChunks","array1","array2","offset","mapping","totalBytes","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","_i3","_Object$entries","_Object$entries$_i","bufferIndices","_step2","_iterator2","bufferIndex","_x","_x2","_x3","_x4","CornerstoneSR","CornerstoneSEG","labelmaps3DorBrushData","cornerstoneToolsVersion","Segmentation_4X","Segmentation_3X","__assign","t","prototype","hasOwnProperty","call","this","__spreadArray","to","pack","ar","l","CodingScheme","codeValues","worldToImageCoords","cornersoneFreeTextCodingValue","Cornerstone3DCodingScheme","freeTextLabel","fs","generateDatasetMeta","sopInstanceUIDToImageIdMap","referencedImageId","annotation","annotationUID","frameOfReferenceUID","label","getCornerstoneLabelFromDefaultState","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","instance","dsd","generateDerivationSourceDataset","tid1500MeasurementReport","imageToWorldCoords","CORNERSTONE_3D_TAG","worldCoords","point","imagePixelModule","xOffset","yOffset","secondPoint","arrowFirst","activeHandleIndex","_data$handles","pointImage","cornerstone3DTag","width","shortAxisPoints","longAxisPoints","firstPointPairs","secondPointPairs","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","MEASUREMENT_TYPE","angle","start1","end1","trackingIdentifier","toLowerCase","CircleROI","pointsWorld","worldPos","EPSILON","EllipticalROI","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","ellipsePoints","top","bottom","left","right","rotation","TOOLTYPE","RectangleROI","corners","_defineProperty","_data$cachedStats","PLANARFREEHANDROI","PlanarFreehandROI","isOpenContour","pop","polyline","firstPoint","PROBE","Probe","generateToolStateCornerstoneLegacy","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","scalarData","dimensions","segmentsOnLabelmap3D","Set","add","image","SOPClassUID","SopClassUID","SOPInstanceUID","SopInstanceUID","getPixelData","_createMultiframeSegmentationFromReferencedImages","Colors","normalize","den","sum","norm","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","constructor","name","cielab","rgba","RecommendedDisplayCIELabValue","dicomlab2RGB","SegmentNumber","functionalGroups","size","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","geometry","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","origin","spacing","PixelSpacing","SpacingBetweenSlices","out","Zx","Zy","Zz","columnStepToPatient","rowStepToPatient","planeNormal","sliceStep","a","b","subtract","direction","geometryFromFunctionalGroups","exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","arr","Arr","_byteLength","curByte","revLookup","charCodeAt","fromByteArray","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","indexOf","num","output","base64","ieee754","customInspectSymbol","Symbol","K_MAX_LENGTH","createBuffer","RangeError","buf","setPrototypeOf","arg","encodingOrOffset","TypeError","allocUnsafe","string","encoding","isEncoding","actual","fromString","isView","arrayView","isInstance","copy","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","obj","isBuffer","checked","numberIsNaN","fromObject","toPrimitive","assertSize","array","toString","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","asciiToBytes","base64Write","ucs2Write","units","c","hi","lo","utf16leToBytes","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","defineProperty","enumerable","poolSize","alloc","allocUnsafeSlow","_isBuffer","compare","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","isFinite","toJSON","_arr","ret","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","INVALID_BASE64_RE","Infinity","leadSurrogate","base64clean","src","dst","alphabet","table","i16","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","NaN","rt","isNaN","LN2","module","iota","hasTypedArrays","Float64Array","compare1st","order","stride","terms","sort","compileConstructor","dtype","dimension","className","useGetters","Function","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","shape","ctor","sz","arrayDType","ctor_list"],"sourceRoot":""}